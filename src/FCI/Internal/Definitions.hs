{-# language MagicHash #-}

-- | Core definitions.
module FCI.Internal.Definitions (
    Inst
  , Dict
  , inst
  , (==>)
  ) where

import Data.Kind
import GHC.Exts

{- [FCI primitives] -----------------------------------------------------------

In GHC, there are at least two ways to get access to typeclass dictionaries -
using 'unsafeCoerce' on newtype-wrapped function or with Core plugin that
replaces use of magic functions with use of coerced, explicit dictionaries.
First option is what 'reflection' does and what we do in ghci, where
source-transforming plugins do not work yet. Problem is that this solution is
brittle in presence of optimizations - 'reflection' tends to break with new
compiler releases and requires disabling otherwise beneficial optimizations.
That's why we instead require users to enable plugin and use wrapping version
only in ghci, where optimizations aren't generally enabled.

------------------------------------------------------------------------------}

-------------------------------------------------------------------------------
infixr 0 ==>
infixr 1 :=>

-------------------------------------------------------------------------------
-- | Type family that maps constraint to it's first class representation -
-- should be generally used instead of it's concrete result for consistency.
--
-- TODO: example
-- TODO: has to be tc plugin - tuples, QuantifiedConstraints etc.
type family Inst (c :: Constraint) = (t :: Type) | t -> c

-------------------------------------------------------------------------------
-- | Data family, instances of which are generated by TH for normal typeclasses
-- (see 'FCINew.TH.mkInstRep'). Do not write these by hand, instead, create new
-- instance of 'Inst' mapping to separate datatype.
--
-- TODO: format of generated instance
data family Dict :: Constraint -> Type

-------------------------------------------------------------------------------
-- | /Reflects/ constraint into correspoding representation - can be used to
-- access normal class instances from the environment. This function is meant
-- to be used with @TypeApplications@ when it's usage is ambiguous.
--
-- TODO: example
inst :: forall c. c => Inst c
-- See [FCI primitives] - in short, this should be replaced by plugin outside
-- of ghci!
inst = case unsafeCoerce# id :: c :=> Inst c of Wants d -> d
{-# noinline inst #-}

-------------------------------------------------------------------------------
-- | /Reifies/ first class instance into constraint in context of supplied
-- continuation.
--
-- TODO: example
(==>) :: forall c r. Inst c -> (c => r) -> r
-- See [FCI primitives] - in short, this should be replaced by plugin outside
-- of ghci!
d ==> x = unsafeCoerce# (Wants @c @r x) d
{-# noinline (==>) #-}

-------------------------------------------------------------------------------
-- See [FCI primitives].
newtype c :=> r where
  Wants :: (c => r) -> c :=> r